---
title: "Actividad semana 14"
author: "Raquel Martin"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    highlight: tango
    latex_engine: xelatex
    fig_caption: true
  rmarkdown::pdf_document: default 
  word_document:
    toc: yes
  html_document: 
    toc: yes
    df_print: paged
always_allow_html: yes
---


```{r setup, include = FALSE, echo = FALSE}

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, comment = NA)

library(agricolae)
library(car) #dataset Davis
library(ggplot2)
library(grid)
library(kableExtra)
library(latexpdf)
library(modeest)
library(plotly)
library(plyr)
library(gridExtra)
library(prettyR)
library(stats)
library(tidyverse)
library(webshot)
```

***

## <span style = "color:blue">** Pregunta 1.	Si la distribución de los datos es asimétrica, ¿qué estadístico(s) emplearías?** </span>


**Respuesta 1.** Si la distribución de los datos es asimétrica, es recomendable emplear **estadísticos robustos**, ya que son menos sensibles a la presencia de valores atípicos.

En el caso de variables **numéricas**, utilizaría la **mediana**, que representa el valor central de un conjunto de datos ordenados y resulta más adecuada que la media cuando existen valores extremos.  
Para variables **categóricas**, emplearía la **moda**, que es la categoría que aparece con mayor frecuencia.

También utilizaría los **cuartiles** (Q1 y Q3) para describir la distribución de los datos y detectar posibles valores atípicos, así como el **rango intercuartílico (IQR)** para medir la dispersión.


## <span style = "color:blue">** Pregunta 2. Cuando los datos presentan potenciales "outliers", ¿qué estadístico(s) emplearías?** </span>

**Respuesta 2** En presencia de outliers, además de usar estadísticos estables, como la mediana, los cuartiles y el rango intercuartílico, evitaría el uso de la media y la desviación estándar, ya que pueden verse fuertemente influenciadas por valores extremos.


## <span style = "color:blue">** Pregunta 3. Un boxplot, ¿permite identificar rápidamente la desviación estándar? ¿por qué?** </span>

**Respuesta 3.** No. Un boxplot no permite identificar directamente la desviación estándar.
El boxplot representa la mediana, los cuartiles y el rango intercuartílico (IQR).
Aunque puede dar una idea general de la dispersión de los datos, no permite calcular ni estimar la desviación estándar de forma precisa.


## <span style = "color:blue">** Pregunta 4. ¿Con qué otros nombres podemos referirnos a las variables cualitativas?** </span>
**Respuesta4.** También se conocen como **variables categóricas**, **variables nominales** y **variables ordinales**. Las variables categóricas son aquellas que toman como valores distintas categorías u etiquetas. Las nominales, se refieren a las variables cualitativas donde las categorías no tienen orden y finalmente, las variables ordinales son aquellas variables cualitativas que tienen un orden significativo. 


## <span style = "color:blue">** Pregunta 5. Dataset "Davis": Calcula los estadísticos de 1 de las variables numéricas y de 1 de las variables factor.** </span>


```{r}

data (Davis)

data = Davis

attach (data)

head (data)

data %>% head(5) %>% kable() %>% # Visualización de datos en un formato como excel

  kable_styling("striped",
                full_width = FALSE,
                position = "center",
                font_size = 16) %>%
  row_spec(0,monospace = T, bold = T, color = "blue") %>%
  row_spec(1:ncol(data), color = "white", background = "#808080")
str(data)

```


```{r}
#convertir a variables numericas. 

data$weight = as.numeric(data$weight)
data$height = as.numeric(data$height)
data$repwt = as.numeric(data$repwt)
data$repht = as.numeric(data$repht)

#Lo que antes se cogía como números enteros (Int) ahora se coge como numéricos (Num).
str(data)
```



```{r}

variables_numericas_df = data %>%
  select(where(is.numeric)) %>%
  names()

variables_numericas_df

variables_factor_df = data %>%
  select(where(is.factor)) %>%
  names()

variables_factor_df

```

```{r}
#selecciona las columnas que son numéricas
variables_numericas_df <- data %>%
  select(where(is.numeric))

#crea un dataframe con nombres de columnas pero sin datos para almacenar los resultados
df_estadisticos_numericos <- data.frame(variable = character(),
                                        Media = numeric(),
                                        Mediana = numeric(),
                                        IQR = numeric())

#Para cada columna que es numérica que calcula los estadísticos.
for (i in names(variables_numericas_df)) {
  
  #calcula los estadísticos
  media <- round(mean(variables_numericas_df[[i]], na.rm = TRUE), 2)
  mediana <- round(median(variables_numericas_df[[i]], na.rm = TRUE), 2)
  IQR <- round (IQR(variables_numericas_df[[i]], na.rm = TRUE), 2)
  
  #crea un dataframe temporal con los resultados
  df_temp <- data.frame(Variable = i,
                        Media = media,
                        Mediana = mediana,
                        IQR = IQR)
  
  #Añade el dataframe temporal al dataframe de resultados. Mediante rbind se unen filas.
  df_estadisticos_numericos <- rbind(df_estadisticos_numericos, df_temp)
}

print(df_estadisticos_numericos)

```

```{r}

for (i in 1:nrow(df_estadisticos_numericos)) {
  
  #Usa la función cat para imprimir los resultados sin índices
  cat(paste("Variable:", df_estadisticos_numericos$Variable[i], "\n",
            "Media:", df_estadisticos_numericos$Media[i], "\n",
            "Mediana:", df_estadisticos_numericos$Mediana[i], "\n",
            "IQR:", df_estadisticos_numericos$IQR[i], "\n\n"))
  
}

```

```{r}

#Crea una lista vacia para almacenar los resultados

resultados_n <- list()

for (i in 1:nrow(df_estadisticos_numericos)) {
  
  #obtienes los valores de la fila
  variable <- df_estadisticos_numericos$Variable[i]
  media <- df_estadisticos_numericos$Media[i]
  mediana <- df_estadisticos_numericos$Mediana[i]
  IQR <- df_estadisticos_numericos$IQR[i]
  
  #Formatea los resultados como una cadena de texto
  resultado_num <- paste("Para la variable", variable, "la media es", media, "la mediana es", mediana, "y el IQR es", IQR, ".")
  
  #Agrega el resultado a la lista
  resultados_n[[i]] <- resultado_num
  
  
}

for (resultado_num in resultados_n) {
  cat(resultado_num, "\n")
}

```

```{r}
#Selecciona las columnas que son factor
variables_factor_df <- data %>%
  select(where(is.factor))

#crea un dataframe vacio para almacenar los resultados
df_estadisticos_factor <- data.frame()

for (i in names(variables_factor_df)) {
  
  #obtiene los niveles y las frecuencias
  niveles <- levels(variables_factor_df[[i]])
  frecuencias <- table(variables_factor_df[[i]])
  
  #crea un dataframe temporal con los resultados
  df_temp <- data.frame(Variable = i, 
                        Nivel = niveles,
                        Frecuencia = as.numeric(frecuencias))
  
  #Añade el dataframe temporal al dataframe de resultados
  df_estadisticos_factor <- rbind(df_estadisticos_factor, df_temp)
  
}

print(df_estadisticos_factor)

```

```{r}
#crea una lista vacia para almacenar los resultados
resultados_f <- list()

for (i in 1:nrow(df_estadisticos_factor)) {
  
  #obtener los valores de la fila
  variable <- df_estadisticos_factor$Variable[i]
  nivel <- df_estadisticos_factor$Nivel[i]
  frecuencia <- df_estadisticos_factor$Frecuencia[i]
  
  #Formatea el resultado como una cadena de texto
  resultado_factor <- paste ("La frecuencia del nivel", nivel,"de la variable", variable, "es", frecuencia, ".")
  
  #Agrega el resultado a la lista
  resultados_f[[i <- resultado_factor]]
}

for (resultado_factor in resultados_f) {
  cat(resultado_factor, "\n")
}

```


```{r}
#Para tenerlo todo junto

for (resultado_num in resultados_n) {
  cat(resultado_num, "\n")
}

for (resultado_factor in resultados_f) {
  cat(resultado_factor, "\n")
}
  
```

## <span style = "color:blue"> ** Pregunta 6. Dataset "Davis":Comprueba gráficamente, para las variables numéricas, si existen potenciales outliers.** </span>

```{r}
#Crea una version larga del conjunto de datos, necesario por ggplot2. Una columna van a ser las variables y la otra los valores.
data_long <- gather(variables_numericas_df, key = "variable", value = "value")

#crear un diagrama de caja para cada variable numérica
p <- ggplot(data_long, aes(x = variable, y = value, fill = variable)) + 
  geom_boxplot() + #para ver si hay valores atípicos
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        axis.text.y = element_blank(), #Añade esta linea
        axis.ticks.y = element_blank()) + #Añade esta linea
  labs(title = "Boxplot para cada variable numérica",
       x = "Variable",
       y = "Valor")


#Convertir el gráfico de ggplot a un grafico interactivo de plotly
p_interactive <- ggplotly(p)

#imprimir el grafico interactivo
p_interactive


```


```{r}

#Crea un dataframe vacio para almacenar los outliers
outliers_df <- data.frame()

#Recorre cada columna del dataframe
for (variable in colnames(variables_numericas_df)){
  
  #omitir NA
  data <- variables_numericas_df [[variable]]
  data <- data[!is.na(data)]
  
  #calcula el IQR
  IQR <- IQR(data, na.rm = TRUE)
  
  #calcula los cuartiles 
  Q1 <- quantile(data, .25, na.rm = TRUE)
  Q3 <- quantile(data, .75, na.rm = TRUE)
  
  #Define los límites para los outliers
  lower_bound <- Q1 - 1.5 * IQR
  upper_bound <- Q3 + 1.5 * IQR
  
  # Encuentra los outliers
  outliers <- data[data < lower_bound | data > upper_bound]
  
  #Si hay outliers, añadelos al dataframe de outliers
  if (length(outliers)>0){
    temp_df <- data.frame(Variable = variable, Outlier = outliers)
    outliers_df <- rbind (outliers_df, temp_df)
    
  }
}

outliers_df

```

```{r}

#Crea una lista para almacenar los resultados
resultados_out <- list()

#Recorre cada columna del dataframe
for (i in 1:length(colnames(variables_numericas_df))) {
  
  #omitir NA
  variable <- colnames(variables_numericas_df)[i]
  data <- variables_numericas_df[[variable]]
  data <- data[!is.na(data)]

  #Calcula el IQR
  IQR <- IQR(data, na.rm = TRUE)
  
  #Calcula los cuartiles
  Q1 <- quantile(data, .25, na.rm = TRUE)
  Q3 <- quantile(data, .75, na.rm = TRUE)
  
  #Define los límites para los outliers
  lower_bound <- Q1 - 1.5 * IQR
  upper_bound <- Q3 + 1.5 * IQR
  
  #Encuentra los outliers
  outliers <- data[data < lower_bound | data > upper_bound]
  
  #Si hay outliers, añadelos al dataframe de outliers
  if (length(outliers) > 0) {
      resultado_outliers <- paste ("Los outliers de la variable", variable, "son los valores", 
  toString(outliers), "")
      resultados_out [[i]] <- resultado_outliers
  }
}

#Ahora puedes acceder a los resultados fuera del bucle 
#Usa la función cat para imprimir los resultados sin índices
for (resultado_outliers in resultados_out) {
  cat(resultado_outliers, "\n")
  
}
```
```{r}

# Función para comprobar la normalidad
comprobar_normalidad <- function(data) {
  resultado <- data.frame()
  
  for (nombre_variable in names(data)) {
    if (is.numeric(data[[nombre_variable]])) {
      test <- shapiro.test(data[[nombre_variable]])
      es_normal <- ifelse(test$p.value > 0.05, "Si", "No")
      temp_df <- data.frame(Variable = nombre_variable, p_value = test$p.value, Distribucion_normal = es_normal)
      resultado <- rbind(resultado, temp_df)
    }
  }
  return (resultado)
}

# Llamada a la función 
resultado <- comprobar_normalidad(variables_numericas_df)
print(resultado)

```
## <span style = "color:blue"> ** Pregunta 7. Dibuja un histograma para las variables numéricas.** </span>


```{r}

data (Davis)
data = Davis

#Definir la función necesaria

histograma <- function (df) {
  columnas_numericas <- sapply (df, is.numeric)
  for (nombre_columna in names (df) [columnas_numericas]) {
    p <- ggplot(df, aes_string(nombre_columna)) + 
      geom_histogram(binwidth = 10, fill = "darkcyan", color = "black") +
      labs(title = paste ("Histograma de", nombre_columna),
           x = nombre_columna,
           y = "Frecuencia")
    print(p)
    }
}
  histograma(data)
  
```

